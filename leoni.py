# -*- coding: utf-8 -*-
"""leoni.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17LIjyfH1QubcD-zMuj9xZ1omMQ8Nze70

Project (3 parts):

1-Face detection

2-Facial Recognition

3-Emotion detection

*Installations needed for the whole project*
"""

import numpy as np
import tensorflow as tf
import os
import PIL
import PIL.Image
import pandas as pd

print(tf.__version__)

"""---We are going to use Kaggle datasets, upload them to our notebook using Kaggle API---"""

! pip install kaggle

! mkdir ~/.kaggle

! cp kaggle.json ~/.kaggle/

! chmod 600 ~/.kaggle/kaggle.json

"""*Part1: Face detection*"""

#!kaggle datasets download -d stoicstatic/face-recognition-dataset

#!unzip face-recognition-dataset.zip

from IPython.display import Image
pil_img = Image(filename='/content/face.jpg')
display(pil_img)

"""1.1 Face detection using Haarcascade classifier"""

import cv2
import sys

cv2.__version__

"""---Haarcascade classifier already built in opencv---"""

imagePath = sys.argv[1]
cascPath = "haarcascade_frontalface_default.xml"

"""--We can add specificities like eyes detection or anyother feature needed to future use--"""

face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + cascPath)
eye_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_eye.xml')

image = cv2.imread('/content/face.jpg')
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

faces = face_cascade.detectMultiScale(gray, 1.1, 2)

for (x,y,w,h) in faces:
    cv2.rectangle(image,(x,y),(x+w,y+h),(255,0,0),2)
    roi_gray = gray[y:y+h, x:x+w]
    roi_color = image[y:y+h, x:x+w]
    eyes = eye_cascade.detectMultiScale(roi_gray)
    for (ex,ey,ew,eh) in eyes:
        cv2.rectangle(roi_color,(ex,ey),(ex+ew,ey+eh),(0,255,0),2)

"""---Having all the code in one function---"""

def detect(path):
  image = cv2.imread(path)
  gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
  faces = face_cascade.detectMultiScale(gray, 1.1, 3)
  for (x,y,w,h) in faces:
    cv2.rectangle(image,(x,y),(x+w,y+h),(255,0,0),2)
    roi_gray = gray[y:y+h, x:x+w]
    roi_color = image[y:y+h, x:x+w]
    eyes = eye_cascade.detectMultiScale(roi_gray)
    for (ex,ey,ew,eh) in eyes:
        cv2.rectangle(roi_color,(ex,ey),(ex+ew,ey+eh),(0,255,0),2)
  from google.colab.patches import cv2_imshow
  cv2_imshow(image)

detect('/content/face.jpg')

"""---Webcam captured images---



"""

# import dependencies
from IPython.display import display, Javascript, Image
from google.colab.output import eval_js
from base64 import b64decode, b64encode
import cv2
import numpy as np
import PIL
import io
import html
import time

"""---Helper functions of JS: convert images from javascript to opencv---"""

# function to convert the JavaScript object into an OpenCV image
def js_to_image(js_reply):
  """
  Params:
          js_reply: JavaScript object containing image from webcam
  Returns:
          img: OpenCV BGR image
  """
  # decode base64 image
  image_bytes = b64decode(js_reply.split(',')[1])
  # convert bytes to numpy array
  jpg_as_np = np.frombuffer(image_bytes, dtype=np.uint8)
  # decode numpy array into OpenCV BGR image
  img = cv2.imdecode(jpg_as_np, flags=1)

  return img

# function to convert OpenCV Rectangle bounding box image into base64 byte string to be overlayed on video stream
def bbox_to_bytes(bbox_array):
  """
  Params:
          bbox_array: Numpy array (pixels) containing rectangle to overlay on video stream.
  Returns:
        bytes: Base64 image byte string
  """
  # convert array into PIL image
  bbox_PIL = PIL.Image.fromarray(bbox_array, 'RGBA')
  iobuf = io.BytesIO()
  # format bbox into png for return
  bbox_PIL.save(iobuf, format='png')
  # format return string
  bbox_bytes = 'data:image/png;base64,{}'.format((str(b64encode(iobuf.getvalue()), 'utf-8')))

  return bbox_bytes

"""---Use code within Google Colab's **Code Snippets** that has a variety of useful code functions to perform various tasks.--

--We will be using the code snippet for **Camera Capture** to utilize your computer's webcam.--
"""

from IPython.display import display, Javascript
from google.colab.output import eval_js
from base64 import b64decode

def take_photo(filename='photo.jpg', quality=0.8):
#photo.jpg is the variable which will store the captured image
  js = Javascript('''
    async function takePhoto(quality) {
      const div = document.createElement('div');
      const capture = document.createElement('button');
      capture.textContent = 'Capture';
      div.appendChild(capture);

      const video = document.createElement('video');
      video.style.display = 'block';
      const stream = await navigator.mediaDevices.getUserMedia({video: true});

      document.body.appendChild(div);
      div.appendChild(video);
      video.srcObject = stream;
      await video.play();

      // Resize the output to fit the video element.
      google.colab.output.setIframeHeight(document.documentElement.scrollHeight, true);

      // Wait for Capture to be clicked.
      await new Promise((resolve) => capture.onclick = resolve);

      const canvas = document.createElement('canvas');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      canvas.getContext('2d').drawImage(video, 0, 0);
      stream.getVideoTracks()[0].stop();
      div.remove();
      return canvas.toDataURL('image/jpeg', quality);
    }
    ''')
  display(js)
  # get photo data
  data = eval_js('takePhoto({})'.format(quality))
  # get OpenCV format image
  img = js_to_image(data)
  # grayscale img
  gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
  print(gray.shape)
  # get face bounding box coordinates using Haar Cascade
  faces = face_cascade.detectMultiScale(gray,1.1,3)
  # draw face bounding box on image
  for (x,y,w,h) in faces:
      img = cv2.rectangle(img,(x,y),(x+w,y+h),(255,0,0),2)
      cv2.putText(img, 'Face', (x, y-10), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (36,255,12), 2)
  # save image
  cv2.imwrite(filename, img)

  return filename

try:
  filename = take_photo('photo.jpg')
  print('Saved to {}'.format(filename))

  # Show the image which was just taken.
  display(Image(filename))


except Exception as err:
  # Errors will be thrown if the user does not have a webcam or if they do not
  # grant the page permission to access it.
  print(str(err))
#it will give us the hight and width
#it will save the capture into photo.jpg found in the left

"""---Real time videos---"""

# JavaScript to properly create our live video stream using our webcam as input
def video_stream():
  js = Javascript('''
    var video;
    var div = null;
    var stream;
    var captureCanvas;
    var imgElement;
    var labelElement;

    var pendingResolve = null;
    var shutdown = false;

    function removeDom() {
       stream.getVideoTracks()[0].stop();
       video.remove();
       div.remove();
       video = null;
       div = null;
       stream = null;
       imgElement = null;
       captureCanvas = null;
       labelElement = null;
    }

    function onAnimationFrame() {
      if (!shutdown) {
        window.requestAnimationFrame(onAnimationFrame);
      }
      if (pendingResolve) {
        var result = "";
        if (!shutdown) {
          captureCanvas.getContext('2d').drawImage(video, 0, 0, 640, 480);
          result = captureCanvas.toDataURL('image/jpeg', 0.8)
        }
        var lp = pendingResolve;
        pendingResolve = null;
        lp(result);
      }
    }

    async function createDom() {
      if (div !== null) {
        return stream;
      }

      div = document.createElement('div');
      div.style.border = '2px solid black';
      div.style.padding = '3px';
      div.style.width = '100%';
      div.style.maxWidth = '600px';
      document.body.appendChild(div);

      const modelOut = document.createElement('div');
      modelOut.innerHTML = "<span>Status:</span>";
      labelElement = document.createElement('span');
      labelElement.innerText = 'No data';
      labelElement.style.fontWeight = 'bold';
      modelOut.appendChild(labelElement);
      div.appendChild(modelOut);

      video = document.createElement('video');
      video.style.display = 'block';
      video.width = div.clientWidth - 6;
      video.setAttribute('playsinline', '');
      video.onclick = () => { shutdown = true; };
      stream = await navigator.mediaDevices.getUserMedia(
          {video: { facingMode: "environment"}});
      div.appendChild(video);

      imgElement = document.createElement('img');
      imgElement.style.position = 'absolute';
      imgElement.style.zIndex = 1;
      imgElement.onclick = () => { shutdown = true; };
      div.appendChild(imgElement);

      const instruction = document.createElement('div');
      instruction.innerHTML =
          '<span style="color: red; font-weight: bold;">' +
          'When finished, click here or on the video to stop this demo</span>';
      div.appendChild(instruction);
      instruction.onclick = () => { shutdown = true; };

      video.srcObject = stream;
      await video.play();

      captureCanvas = document.createElement('canvas');
      captureCanvas.width = 640; //video.videoWidth;
      captureCanvas.height = 480; //video.videoHeight;
      window.requestAnimationFrame(onAnimationFrame);

      return stream;
    }
    async function stream_frame(label, imgData) {
      if (shutdown) {
        removeDom();
        shutdown = false;
        return '';
      }

      var preCreate = Date.now();
      stream = await createDom();

      var preShow = Date.now();
      if (label != "") {
        labelElement.innerHTML = label;
      }

      if (imgData != "") {
        var videoRect = video.getClientRects()[0];
        imgElement.style.top = videoRect.top + "px";
        imgElement.style.left = videoRect.left + "px";
        imgElement.style.width = videoRect.width + "px";
        imgElement.style.height = videoRect.height + "px";
        imgElement.src = imgData;
      }

      var preCapture = Date.now();
      var result = await new Promise(function(resolve, reject) {
        pendingResolve = resolve;
      });
      shutdown = false;

      return {'create': preShow - preCreate,
              'show': preCapture - preShow,
              'capture': Date.now() - preCapture,
              'img': result};
    }
    ''')

  display(js)

def video_frame(label, bbox):
  data = eval_js('stream_frame("{}", "{}")'.format(label, bbox))
  return data

# start streaming video from webcam
video_stream()
# label for video
label_html = 'Capturing...'
# initialze bounding box to empty
bbox = ''
count = 0
while True:
    js_reply = video_frame(label_html, bbox)
    if not js_reply:
        break

    # convert JS response to OpenCV Image
    img = js_to_image(js_reply["img"])

    # create transparent overlay for bounding box
    bbox_array = np.zeros([480,640,4], dtype=np.uint8) #the different thing between image capturing and video capturing

    # grayscale image for face detection
    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)

    # get face region coordinates
    faces = face_cascade.detectMultiScale(gray,1.1,3)
    # get face bounding box for overlay
    for (x,y,w,h) in faces:
      bbox_array = cv2.rectangle(bbox_array,(x,y),(x+w,y+h),(255,0,0),2)
      cv2.putText(bbox_array, 'Face Detection', (x, y-10), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (36,255,12), 2)

    bbox_array[:,:,3] = (bbox_array.max(axis = 2) > 0 ).astype(int) * 255
    # convert overlay of bbox into bytes
    bbox_bytes = bbox_to_bytes(bbox_array)
    # update bbox so next frame gets new overlay
    bbox = bbox_bytes

"""1.2 Face detection using Yolov4"""

# Commented out IPython magic to ensure Python compatibility.
# import dependencies
from IPython.display import display, Javascript, Image
from google.colab.output import eval_js
from google.colab.patches import cv2_imshow
from base64 import b64decode, b64encode
import cv2
import numpy as np
import PIL
import io
import html
import time
import matplotlib.pyplot as plt
# %matplotlib inline

# clone darknet repo
!git clone https://github.com/AlexeyAB/darknet

# Commented out IPython magic to ensure Python compatibility.
# change makefile to have GPU, OPENCV and LIBSO enabled
# %cd darknet
!sed -i 's/OPENCV=0/OPENCV=1/' Makefile
!sed -i 's/GPU=0/GPU=1/' Makefile
!sed -i 's/CUDNN=0/CUDNN=1/' Makefile
!sed -i 's/CUDNN_HALF=0/CUDNN_HALF=1/' Makefile
!sed -i 's/LIBSO=0/LIBSO=1/' Makefile

# make darknet (builds darknet so that you can then use the darknet.py file and have its dependencies)
!make

# get bthe scaled yolov4 weights file that is pre-trained to detect 80 classes (objects) from shared google drive
!wget --load-cookies /tmp/cookies.txt "https://docs.google.com/uc?export=download&confirm=$(wget --quiet --save-cookies /tmp/cookies.txt --keep-session-cookies --no-check-certificate 'https://docs.google.com/uc?export=download&id=1V3vsIaxAlGWvK4Aar9bAiK5U0QFttKwq' -O- | sed -rn 's/.*confirm=([0-9A-Za-z_]+).*/\1\n/p')&id=1V3vsIaxAlGWvK4Aar9bAiK5U0QFttKwq" -O yolov4-csp.weights && rm -rf /tmp/cookies.txt

# import darknet functions to perform object detections
from darknet import *
# load in our YOLOv4 architecture network
network, class_names, class_colors = load_network("cfg/yolov4-csp.cfg", "cfg/coco.data", "yolov4-csp.weights")
width = network_width(network)
height = network_height(network)

# darknet helper function to run detection on image
def darknet_helper(img, width, height):
  darknet_image = make_image(width, height, 3)
  img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
  img_resized = cv2.resize(img_rgb, (width, height),
                              interpolation=cv2.INTER_LINEAR)

  # get image ratios to convert bounding boxes to proper size
  img_height, img_width, _ = img.shape
  width_ratio = img_width/width
  height_ratio = img_height/height

  # run model on darknet style image to get detections
  copy_image_from_bytes(darknet_image, img_resized.tobytes())
  detections = detect_image(network, class_names, darknet_image)
  free_image(darknet_image)
  return detections, width_ratio, height_ratio

# run test on person.jpg image that comes with repository
image = cv2.imread("/content/this.jpg")
detections, width_ratio, height_ratio = darknet_helper(image, width, height)

for label, confidence, bbox in detections:
  left, top, right, bottom = bbox2points(bbox)
  left, top, right, bottom = int(left * width_ratio), int(top * height_ratio), int(right * width_ratio), int(bottom * height_ratio)
  cv2.rectangle(image, (left, top), (right, bottom), class_colors[label], 2)
  cv2.putText(image, "{} [{:.2f}]".format(label, float(confidence)),
                    (left, top - 5), cv2.FONT_HERSHEY_SIMPLEX, 0.5,
                    class_colors[label], 2)
cv2_imshow(image)

"""---Webcam captured image---"""

# function to convert the JavaScript object into an OpenCV image
def js_to_image(js_reply):
  """
  Params:
          js_reply: JavaScript object containing image from webcam
  Returns:
          img: OpenCV BGR image
  """
  # decode base64 image
  image_bytes = b64decode(js_reply.split(',')[1])
  # convert bytes to numpy array
  jpg_as_np = np.frombuffer(image_bytes, dtype=np.uint8)
  # decode numpy array into OpenCV BGR image
  img = cv2.imdecode(jpg_as_np, flags=1)

  return img

# function to convert OpenCV Rectangle bounding box image into base64 byte string to be overlayed on video stream
def bbox_to_bytes(bbox_array):
  """
  Params:
          bbox_array: Numpy array (pixels) containing rectangle to overlay on video stream.
  Returns:
        bytes: Base64 image byte string
  """
  # convert array into PIL image
  bbox_PIL = PIL.Image.fromarray(bbox_array, 'RGBA')
  iobuf = io.BytesIO()
  # format bbox into png for return
  bbox_PIL.save(iobuf, format='png')
  # format return string
  bbox_bytes = 'data:image/png;base64,{}'.format((str(b64encode(iobuf.getvalue()), 'utf-8')))

  return bbox_bytes

def take_photo(filename='photo.jpg', quality=0.8):
  js = Javascript('''
    async function takePhoto(quality) {
      const div = document.createElement('div');
      const capture = document.createElement('button');
      capture.textContent = 'Capture';
      div.appendChild(capture);

      const video = document.createElement('video');
      video.style.display = 'block';
      const stream = await navigator.mediaDevices.getUserMedia({video: true});

      document.body.appendChild(div);
      div.appendChild(video);
      video.srcObject = stream;
      await video.play();

      // Resize the output to fit the video element.
      google.colab.output.setIframeHeight(document.documentElement.scrollHeight, true);

      // Wait for Capture to be clicked.
      await new Promise((resolve) => capture.onclick = resolve);

      const canvas = document.createElement('canvas');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      canvas.getContext('2d').drawImage(video, 0, 0);
      stream.getVideoTracks()[0].stop();
      div.remove();
      return canvas.toDataURL('image/jpeg', quality);
    }
    ''')
  display(js)

  # get photo data
  data = eval_js('takePhoto({})'.format(quality))
  # get OpenCV format image
  img = js_to_image(data)

  # call our darknet helper on webcam image
  detections, width_ratio, height_ratio = darknet_helper(img, width, height)

  # loop through detections and draw them on webcam image
  for label, confidence, bbox in detections:
    left, top, right, bottom = bbox2points(bbox)
    left, top, right, bottom = int(left * width_ratio), int(top * height_ratio), int(right * width_ratio), int(bottom * height_ratio)
    cv2.rectangle(img, (left, top), (right, bottom), class_colors[label], 2)
    cv2.putText(img, "{} [{:.2f}]".format(label, float(confidence)),
                      (left, top - 5), cv2.FONT_HERSHEY_SIMPLEX, 0.5,
                      class_colors[label], 2)
  # save image
  cv2.imwrite(filename, img)

  return filename

try:
  filename = take_photo('photo.jpg')
  print('Saved to {}'.format(filename))

  # Show the image which was just taken.
  display(Image(filename))
except Exception as err:
  # Errors will be thrown if the user does not have a webcam or if they do not
  # grant the page permission to access it.
  print(str(err))

"""---Real time video---"""

# JavaScript to properly create our live video stream using our webcam as input
def video_stream():
  js = Javascript('''
    var video;
    var div = null;
    var stream;
    var captureCanvas;
    var imgElement;
    var labelElement;

    var pendingResolve = null;
    var shutdown = false;

    function removeDom() {
       stream.getVideoTracks()[0].stop();
       video.remove();
       div.remove();
       video = null;
       div = null;
       stream = null;
       imgElement = null;
       captureCanvas = null;
       labelElement = null;
    }

    function onAnimationFrame() {
      if (!shutdown) {
        window.requestAnimationFrame(onAnimationFrame);
      }
      if (pendingResolve) {
        var result = "";
        if (!shutdown) {
          captureCanvas.getContext('2d').drawImage(video, 0, 0, 640, 480);
          result = captureCanvas.toDataURL('image/jpeg', 0.8)
        }
        var lp = pendingResolve;
        pendingResolve = null;
        lp(result);
      }
    }

    async function createDom() {
      if (div !== null) {
        return stream;
      }

      div = document.createElement('div');
      div.style.border = '2px solid black';
      div.style.padding = '3px';
      div.style.width = '100%';
      div.style.maxWidth = '600px';
      document.body.appendChild(div);

      const modelOut = document.createElement('div');
      modelOut.innerHTML = "<span>Status:</span>";
      labelElement = document.createElement('span');
      labelElement.innerText = 'No data';
      labelElement.style.fontWeight = 'bold';
      modelOut.appendChild(labelElement);
      div.appendChild(modelOut);

      video = document.createElement('video');
      video.style.display = 'block';
      video.width = div.clientWidth - 6;
      video.setAttribute('playsinline', '');
      video.onclick = () => { shutdown = true; };
      stream = await navigator.mediaDevices.getUserMedia(
          {video: { facingMode: "environment"}});
      div.appendChild(video);

      imgElement = document.createElement('img');
      imgElement.style.position = 'absolute';
      imgElement.style.zIndex = 1;
      imgElement.onclick = () => { shutdown = true; };
      div.appendChild(imgElement);

      const instruction = document.createElement('div');
      instruction.innerHTML =
          '<span style="color: red; font-weight: bold;">' +
          'When finished, click here or on the video to stop this demo</span>';
      div.appendChild(instruction);
      instruction.onclick = () => { shutdown = true; };

      video.srcObject = stream;
      await video.play();

      captureCanvas = document.createElement('canvas');
      captureCanvas.width = 640; //video.videoWidth;
      captureCanvas.height = 480; //video.videoHeight;
      window.requestAnimationFrame(onAnimationFrame);

      return stream;
    }
    async function stream_frame(label, imgData) {
      if (shutdown) {
        removeDom();
        shutdown = false;
        return '';
      }

      var preCreate = Date.now();
      stream = await createDom();

      var preShow = Date.now();
      if (label != "") {
        labelElement.innerHTML = label;
      }

      if (imgData != "") {
        var videoRect = video.getClientRects()[0];
        imgElement.style.top = videoRect.top + "px";
        imgElement.style.left = videoRect.left + "px";
        imgElement.style.width = videoRect.width + "px";
        imgElement.style.height = videoRect.height + "px";
        imgElement.src = imgData;
      }

      var preCapture = Date.now();
      var result = await new Promise(function(resolve, reject) {
        pendingResolve = resolve;
      });
      shutdown = false;

      return {'create': preShow - preCreate,
              'show': preCapture - preShow,
              'capture': Date.now() - preCapture,
              'img': result};
    }
    ''')

  display(js)

def video_frame(label, bbox):
  data = eval_js('stream_frame("{}", "{}")'.format(label, bbox))
  return data

# start streaming video from webcam
video_stream()
# label for video
label_html = 'Capturing...'
# initialze bounding box to empty
bbox = ''
count = 0
while True:
    js_reply = video_frame(label_html, bbox)
    if not js_reply:
        break

    # convert JS response to OpenCV Image
    frame = js_to_image(js_reply["img"])

    # create transparent overlay for bounding box
    bbox_array = np.zeros([480,640,4], dtype=np.uint8)

    # call our darknet helper on video frame
    detections, width_ratio, height_ratio = darknet_helper(frame, width, height)

    # loop through detections and draw them on transparent overlay image
    for label, confidence, bbox in detections:
      left, top, right, bottom = bbox2points(bbox)
      left, top, right, bottom = int(left * width_ratio), int(top * height_ratio), int(right * width_ratio), int(bottom * height_ratio)
      bbox_array = cv2.rectangle(bbox_array, (left, top), (right, bottom), class_colors[label], 2)
      bbox_array = cv2.putText(bbox_array, "{} [{:.2f}]".format(label, float(confidence)),
                        (left, top - 5), cv2.FONT_HERSHEY_SIMPLEX, 0.5,
                        class_colors[label], 2)

    bbox_array[:,:,3] = (bbox_array.max(axis = 2) > 0 ).astype(int) * 255
    # convert overlay of bbox into bytes
    bbox_bytes = bbox_to_bytes(bbox_array)
    # update bbox so next frame gets new overlay
    bbox = bbox_bytes

"""*Part2: Facial recognition*

2.1 Downloading the Dataset
"""

! kaggle datasets download -d jessicali9530/lfw-dataset --force

!unzip lfw-dataset.zip

from IPython.display import Image
pil_img = Image(filename='/content/lfw-deepfunneled/lfw-deepfunneled/AJ_Lamas/AJ_Lamas_0001.jpg')
display(pil_img)

"""*lfwallnames.csv: Contains all names of each face in the dataset along with number of images each face has.*"""

!pip install split-folders

import splitfolders
splitfolders.ratio('/content/lfw-deepfunneled/lfw-deepfunneled', output="output", seed=1337, ratio=(0.7, 0.1,0.2))

import splitfolders
splitfolders.ratio('/content/drive/MyDrive/lfw-deepfunneled', output="output", seed=1337, ratio=(0.7, 0.1,0.2))

import cv2
im = cv2.imread('/content/lfw-deepfunneled/lfw-deepfunneled/AJ_Lamas/AJ_Lamas_0001.jpg')
print(type(im))
print(im.shape)
print(type(im.shape))

!rm -rf output

"""*Split data into an output directory*"""

from keras.preprocessing import image
image_size = (48,48)
batch_size = 64
train1 = tf.keras.preprocessing.image_dataset_from_directory('/content/output/train', seed = 1000,image_size=image_size, batch_size = batch_size,color_mode='rgb')

test1 = tf.keras.preprocessing.image_dataset_from_directory('/content/output/test', seed = 1000,image_size=image_size,color_mode='rgb')

validation1 = tf.keras.preprocessing.image_dataset_from_directory('/content/output/val', seed = 1000,image_size=image_size,color_mode='rgb')

"""Build Models"""

import os
from tensorflow import keras
from keras.models import Sequential
import keras
from keras import layers
from keras.layers.core import Flatten, Dense, Dropout
from keras.layers import Convolution2D, MaxPooling2D,AveragePooling2D,Dropout

"""*Checking the size of the dataset images*"""

model1 = keras.Sequential()

model1.add(layers.Conv2D(filters=32, kernel_size=(3, 3), activation='relu', input_shape=(48,48,3),padding='same'))
model1.add(layers.MaxPooling2D(2,2))
model1.add(layers.Dropout(0.1, noise_shape=None, seed=None))


model1.add(layers.Conv2D(filters=64, kernel_size=(3, 3), activation='relu'))
model1.add(layers.MaxPooling2D(2,2))
model1.add(layers.Dropout(0.1, noise_shape=None, seed=None))

model1.add(layers.Conv2D(filters=64, kernel_size=(3, 3), activation='relu', input_shape=(48,48,3),padding='same'))
model1.add(layers.MaxPooling2D(2,2))
model1.add(layers.Dropout(0.1, noise_shape=None, seed=None))


model1.add(layers.Flatten())

model1.add(layers.Dense(units=5749, activation = 'softmax'))

for layer in model1.layers:
    print(layer.output_shape)

model1.summary()

opt = tf.keras.optimizers.Adam(learning_rate=0.01)
#opt=tf.keras.optimizers.SGD(learning_rate=0.1, momentum=1.0, nesterov=False, name="SGD")
model1.compile(optimizer=opt,loss = tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True), metrics=['accuracy'])
es = tf.keras.callbacks.EarlyStopping(monitor='accuracy', verbose=1, patience=1,mode="max")

model1_fit = model1.fit(train1, epochs=5)

model1_evaluate = model1.evaluate(validation1)

import matplotlib.pyplot as plt
plt.plot(model1_fit.history['accuracy'],color="grey")
plt.plot(model1_fit.history['loss'], color = "orange")
plt.ylabel('accuracy')
plt.ylabel('loss/accuracy')
plt.xlabel('epoch')
plt.legend(['accuracy (%)', 'loss'], loc='upper right')
plt.savefig("my face archi plot")

import joblib
import pickle
filename1 = "face recognition my archi.joblib"
joblib.dump(model1, filename1)
print("Saved model to disk")

import joblib
import pickle
filename1 = "face recognition my archi.joblib"
loaded_model1 = joblib.load(filename1)
loaded_model1.summary()

prediction1=model1.predict(test1)
prediction1

df1 = pd.DataFrame(prediction1)
df1['predicted_person_ID']= np.argmax(prediction1, axis=-1)
df1

df1_sum = pd.DataFrame(df1['predicted_person_ID'])
df1_sum

name= pd.read_csv('/content/people.csv')
name

s = pd.Series([i for i in name['name']])
s

index_to_name = dict((i,c) for i, c in enumerate(s))
index_to_name

names=[]
for i in df1_sum['predicted_person_ID']:
  names.append(i)
for i in range(len(names)):
  names[i] = index_to_name.get(names[i])
names

df_names['Names']=pd.DataFrame(names)

df_names = pd.DataFrame(df_names['Names'])
df_names

df_final=pd.DataFrame(df_names['Names'],df1_sum['predicted_person_ID'])
df_final

"""Pretrained models

*CNN Model*

*LeNet5 Architecture*

*7 layers without considering the input layer*![1.jpg](data:image/jpeg;base64,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)
"""

from keras.preprocessing import image
image_size = (240,240)
batch_size = 32
train2 = tf.keras.preprocessing.image_dataset_from_directory('/content/output/train', seed = 1000,image_size=image_size, batch_size = batch_size,color_mode='rgb')

validation2 = tf.keras.preprocessing.image_dataset_from_directory('/content/output/val', seed = 1000,image_size=image_size, batch_size = batch_size,color_mode='rgb')

test2 = tf.keras.preprocessing.image_dataset_from_directory('/content/output/test', seed = 1000,image_size=image_size, batch_size = batch_size,color_mode='rgb')

model2 = keras.models.Sequential([
    keras.layers.Conv2D(6, kernel_size=5, strides=1,  activation='relu', input_shape=(240,240,3)),
    keras.layers.AveragePooling2D(),
    keras.layers.Conv2D(16, kernel_size=5, strides=1, activation='relu', padding='same'),
    keras.layers.AveragePooling2D(),
    keras.layers.Conv2D(120, kernel_size=5, strides=1, activation='relu', padding='same'),
    keras.layers.AveragePooling2D(),
    keras.layers.Flatten(),

    keras.layers.Dense(84, activation='relu'),
    keras.layers.Dense(5749, activation='softmax')
])

opt = tf.keras.optimizers.Adam(learning_rate=0.01)
model2.compile(optimizer=opt, loss=keras.losses.sparse_categorical_crossentropy, metrics=['accuracy'])

model2_fit=model2.fit(train2,epochs=5)

model2.evaluate(validation2)

plt.plot(model2_fit.history['accuracy'],color="black")
plt.plot(model2_fit.history['loss'], color = "red")
plt.title('Accuracy & Loss ')
plt.ylabel('accuracy')
plt.ylabel('loss')
plt.yticks(np.arange(0, 3, 0.25))
plt.xlabel('epoch')
plt.legend(['accuracy', 'loss'], loc='upper right')
plt.savefig("lenet plot")

import joblib
import pickle
filename2 = "face recognition lenet5.joblib"
joblib.dump(model2, filename2)
print("Saved model to disk")

import joblib
import pickle
filename2 = "face recognition lenet5.joblib"
loaded_model2 = joblib.load(filename2)
loaded_model2.summary()

prediction2=model2.predict(test2)
prediction2.shape

df2 = pd.DataFrame(prediction2)
df2['predicted_person']= np.argmax(prediction2, axis=-1)
df2

df2_sum = pd.DataFrame(df2['predicted_person'])
df2_sum

"""3/Emotion Recognition

3.1 Downloading the Dataset from kaggle
"""

! kaggle datasets download -d jonathanoheix/face-expression-recognition-dataset

!unzip face-expression-recognition-dataset.zip

!rm -rf images/images

from IPython.display import Image
pil_img = Image(filename='images/validation/surprise/993.jpg')
display(pil_img)
import cv2
img = cv2.imread('images/validation/surprise/993.jpg')
img.shape
#resized_image = tf.image.resize(img, (48, 48))
#resized_image.shape

from keras.preprocessing import image
image_size = (48,48)
batch_size = 32
train_data = tf.keras.preprocessing.image_dataset_from_directory('images/train', seed = 1000,batch_size = batch_size, image_size=image_size,color_mode='rgb')

test_data = tf.keras.preprocessing.image_dataset_from_directory('images/validation', seed = 1000,image_size=image_size,color_mode='rgb')

"""*Visualising the data*"""

import matplotlib.pyplot as plt
plt.figure(figsize=(10,10))
for images, labels in train_data.take(1):
  for i in range(9):
     ax = plt.subplot(3,3, i+1)
     plt.imshow(images[i].numpy().astype("uint8"))
     plt.title(int(labels[i]))
     plt.axis("off")

"""3.2 Defining the classes

*Giving every class a numerical*
"""

classes = ['angry','disgust','fear','happy','neutral','sad','surprise']
class_to_index = dict((c,i) for i, c in enumerate(classes))
class_to_index

"""*Case studying*"""

switcher={
    0: 'anger',
    1 : 'disgust',
    2: 'fear',
    3:'happy',
    4:'neutral',
    5:'sad',
    6:'surprise',

}
def index_to_class(n):
  return(switcher.get(n))

img=[]
lab=[]
for images, labels in train_data.take(1):
  for i in range(len(images)):
    img.append(images[i].numpy().astype("uint8"))
    lab.append(index_to_class((int(labels[i]))))
    plt.imshow(img[i])
    plt.title(lab[i])
    #print(img[i].shape)

"""3.3 Build the Model"""

import tensorflow as tf
import keras.api._v2.keras as keras
import cv2
import os
from keras_preprocessing.image import ImageDataGenerator
from tensorflow.python.keras.utils import conv_utils
from tensorflow.python.keras.optimizers import *
from keras.models import Sequential
from keras.layers.core import Flatten, Dense, Dropout
from keras.layers.convolutional import Convolution2D, MaxPooling2D, ZeroPadding2D

from keras import layers, models
model = models.Sequential()
model.add(ZeroPadding2D((1,1),input_shape=(48,48,3)))
model.add(layers.Conv2D(32, (3,3), activation='relu'))
model.add(layers.MaxPooling2D(2,2))
model.add(layers.Conv2D(64, (3, 3), activation='relu'))
model.add(layers.MaxPooling2D(2, 2))
model.add(layers.Conv2D(128, (3, 3), activation='relu'))
model.add(layers.Flatten())
model.add(layers.Dense(64, activation='relu'))
model.add(layers.Dense(7,activation='softmax'))

model.summary()

"""*print out a graphic representation of the model*"""

print (tf.keras.utils.plot_model)

tf.keras.utils.plot_model(
    model,
    to_file='model.png',
    show_shapes=False,
    show_dtype=False,
    show_layer_names=True,
    rankdir='TB',
    expand_nested=False,
    dpi=96,
    layer_range=None,
    show_layer_activations=False
)

model.compile(optimizer="adam" ,loss = tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True), metrics=['accuracy'])

train_data

test_data

es = tf.keras.callbacks.EarlyStopping(monitor='accuracy',verbose=1, patience=1,mode="max")
model_fit = model.fit(train_data ,epochs=5)

"""*plot accuarcy & Loss*"""

plt.plot(model_fit.history['accuracy'],color="blue")
plt.plot(model_fit.history['loss'], color = "green")
plt.title('Accuracy & Loss ')
plt.ylabel('accuracy')
plt.ylabel('loss')
plt.xlabel('epoch')
plt.legend(['accuracy', 'loss'], loc='upper right')

model.evaluate(test_data)

import joblib
import pickle
filename = "Emotion2 detection.joblib"
joblib.dump(model, filename)
print("Saved model to disk")

import joblib
import pickle
filename = "Emotion2 detection.joblib"
loaded_model = joblib.load(filename)
loaded_model.summary()

predictions=loaded_model.predict(test_data)
print(predictions)
predicted_class = np.argmax(predictions, axis=-1)
predictions.shape

"""*Show as a dataframe, change the numerique columns to classes*

as reminder:

{'angry': 0,
 'disgust': 1,
 'fear': 2,
 'happy': 3,
 'neutral': 4,
 'sad': 5,
 'surprise': 6}
"""

df = pd.DataFrame(predictions)
df['predicted_class']= predicted_class
df['Class']= [index_to_class(i) for i in predicted_class]
df

df_sum = pd.DataFrame(df['Class'])
df_sum

"""Since we have images with different sizes, we have o adjust the prediction and

---

so the model to any size

Methode1//
"""

from PIL import Image
foo = Image.open("/content/photo.jpg")
# I downsize the image with an ANTIALIAS filter (gives the highest quality)
foo = foo.resize((48,48),Image.ANTIALIAS)
foo.save("methode1.jpg",optimize= True, quality=92)

image = tf.keras.preprocessing.image.load_img('/content/methode1.jpg', target_size=(48, 48))
input_arr = tf.keras.preprocessing.image.img_to_array(image)
input_arr = np.array([input_arr])  # Convert single image to a batch.
input_arr = input_arr.astype('float32') / 255.
predictions = model.predict(input_arr)
predicted_class = np.argmax(predictions, axis=-1)
plt.title(index_to_class(predicted_class[0]))
plt.imshow(image)

"""Methode2//"""

from PIL import Image
import PIL
import os
import glob

base_width = 48
image = Image.open('/content/photo.jpg')
width_percent = (base_width / float(image.size[0]))
hsize = int((float(image.size[1]) * float(width_percent)))
image = image.resize((base_width, hsize), PIL.Image.ANTIALIAS)
base_height = 48
hpercent = (base_height / float(image.size[1]))
wsize = int((float(image.size[0]) * float(hpercent)))
image = image.resize((wsize, base_height), PIL.Image.ANTIALIAS)
image.save("methode2.jpg")

image = tf.keras.preprocessing.image.load_img('/content/methode2.jpg', target_size=(48, 48))
input_arr = tf.keras.preprocessing.image.img_to_array(image)
input_arr = np.array([input_arr])  # Convert single image to a batch.
input_arr = input_arr.astype('float32')/255
predictions = model.predict(input_arr)
predicted_class = np.argmax(predictions, axis=-1)
plt.title(index_to_class(predicted_class[0]))
plt.imshow(image)

"""---> Low resolution

Methode3
"""

from PIL import Image
import os
import PIL
import glob
import matplotlib.pyplot as plt

image = Image.open('/content/photo.jpg')
print(image.size)

resized_image = image.resize((48,48))
print(resized_image.size)

"""Predict emotion"""

input_arr = tf.keras.preprocessing.image.img_to_array(resized_image)
input_arr = np.array([input_arr])  # Convert single image to a batch.
input_arr = input_arr.astype('float32')/255
predictions = loaded_model.predict(input_arr)
predicted_class = np.argmax(predictions, axis=-1)
plt.title(index_to_class(predicted_class[0]),fontsize=20).set_color('Blue')
plt.imshow(image)

"""Recognize the person using model 1"""

input_arr = tf.keras.preprocessing.image.img_to_array(resized_image)
input_arr = np.array([input_arr])  # Convert single image to a batch.
input_arr = input_arr.astype('float32')/255
person = model1.predict(input_arr)
predicted_person = np.argmax(person, axis=-1)
plt.title(index_to_name.get(predicted_person[0]),loc=('right'),fontsize=15)
plt.title(predicted_person[0],loc=('left'),fontsize=15)
plt.imshow(image)